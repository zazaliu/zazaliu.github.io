{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"懒加载","slug":"懒加载","date":"2018-04-04T16:00:00.000Z","updated":"2018-05-05T07:24:16.253Z","comments":true,"path":"2018/04/05/懒加载/","link":"","permalink":"http://yoursite.com/2018/04/05/懒加载/","excerpt":"","text":"懒加载的意义（为什么要使用懒加载）对页面加载速度影响最大的就是图片，一张普通的图片可以达到几M的大小，而代码也许就只有几十KB。当页面图片很多时，页面的加载速度缓慢，几S钟内页面没有加载完成，也许会失去很多的用户。 所以，对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样子对于页面加载性能上会有很大的提升，也提高了用户体验。 原理将页面中的img标签src指向一张小图片或者src为空，然后定义data-src（这个属性可以自定义命名，我才用data-src）属性指向真实的图片。src指向一张默认的图片，否则当src为空时也会向服务器发送一次请求。可以指向loading的地址。 注：图片要指定宽高 1&lt;img src=\"default.jpg\" data-src=\"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg\" /&gt; 当载入页面时，先把可视区域内的img标签的data-src属性值负给src，然后监听滚动事件，把用户即将看到的图片加载。这样便实现了懒加载。 代码在写代码前，需要了解各种高度。先看这篇文章scrollTop,offsetTop,scrollLeft,offsetLeft 12345678910111213141516171819202122232425&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; img &#123; display: block; margin-bottom: 50px; width: 400px; height: 400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=\"default.jpg\" data-src=\"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg\" alt=\"\"&gt; &lt;img src=\"default.jpg\" data-src=\"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg\" alt=\"\"&gt; &lt;img src=\"default.jpg\" data-src=\"http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg\" alt=\"\"&gt; &lt;img src=\"default.jpg\" data-src=\"http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg\" alt=\"\"&gt; &lt;img src=\"default.jpg\" data-src=\"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg\" alt=\"\"&gt; &lt;img src=\"default.jpg\" data-src=\"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg\" alt=\"\"&gt; &lt;img src=\"default.jpg\" data-src=\"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg\" alt=\"\"&gt; &lt;img src=\"default.jpg\" data-src=\"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg\" alt=\"\"&gt; &lt;img src=\"default.jpg\" data-src=\"http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg\" alt=\"\"&gt; &lt;img src=\"default.jpg\" data-src=\"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg\" alt=\"\"&gt; &lt;img src=\"default.jpg\" data-src=\"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg\" alt=\"\"&gt;&lt;/body&gt; JavaScript12345678910111213141516171819&lt;script&gt; var num = document.getElementsByTagName('img').length; var img = document.getElementsByTagName(\"img\"); var n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历 lazyload(); //页面载入完毕加载可视区域内的图片 window.onscroll = lazyload; function lazyload() &#123; //监听页面滚动事件 var seeHeight = document.documentElement.clientHeight; //可见区域高度 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动条距离顶部高度 for (var i = n; i &lt; num; i++) &#123; if (img[i].offsetTop &lt; seeHeight + scrollTop) &#123; if (img[i].getAttribute(\"src\") == \"default.jpg\") &#123; img[i].src = img[i].getAttribute(\"data-src\"); &#125; n = i + 1; &#125; &#125; &#125;&lt;/script&gt; 使用节流函数进行性能优化如果直接将函数绑定在scroll事件上，当页面滚动时，函数会被高频触发，这非常影响浏览器的性能。 我想实现限制触发频率，来优化性能。 节流函数：只允许一个函数在N秒内执行一次。下面是一个简单的节流函数： 1234567891011121314151617181920212223242526// 简单的节流函数//fun 要执行的函数//delay 延迟//time 在time时间内必须执行一次function throttle(fun, delay, time) &#123; var timeout, startTime = new Date(); return function() &#123; var context = this, args = arguments, curTime = new Date(); clearTimeout(timeout); // 如果达到了规定的触发时间间隔，触发 handler if (curTime - startTime &gt;= time) &#123; fun.apply(context, args); startTime = curTime; // 没达到触发间隔，重新设定定时器 &#125; else &#123; timeout = setTimeout(fun, delay); &#125; &#125;;&#125;;// 实际想绑定在 scroll 事件上的 handlerfunction lazyload(event) &#123;&#125;// 采用了节流函数window.addEventListener('scroll',throttle(lazyload,500,1000));","categories":[],"tags":[]},{"title":"ES6 Proxy 与 Reflect","slug":"ES6 Proxy 与 Reflect","date":"2018-03-21T16:00:00.000Z","updated":"2018-05-05T08:23:42.134Z","comments":true,"path":"2018/03/22/ES6 Proxy 与 Reflect/","link":"","permalink":"http://yoursite.com/2018/03/22/ES6 Proxy 与 Reflect/","excerpt":"","text":"1.Proxy 与 Reflect1.1 ProxyProxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。 12345678910var obj = new Proxy(&#123;&#125;, &#123; get: function (target, key, receiver) &#123; console.log(`getting $&#123;key&#125;!`); return Reflect.get(target, key, receiver); &#125;, set: function (target, key, value, receiver) &#123; console.log(`setting $&#123;key&#125;!`); return Reflect.set(target, key, value, receiver); &#125;&#125;); 上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。对设置了拦截行为的对象obj，去读写它的属性，就会得到下面的结果。 123456obj.count = 1// setting count!++obj.count// getting count!// setting count!// 2 上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。 ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。1var proxy = new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。下面是另一个拦截读取属性行为的例子。 123456789var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);proxy.time // 35proxy.name // 35proxy.title // 35 上面代码中，作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个get方法，用来拦截对目标对象属性的访问请求。get方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。 注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。 如果handler没有设置任何拦截，那就等同于直接通向原对象。 12345var target = &#123;&#125;;var handler = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.a = 'b';target.a // \"b\" 上面代码中，handler是一个空对象，没有任何拦截效果，访问handler就等同于访问target。 一个技巧是将Proxy对象，设置到object.proxy属性，从而可以在object对象上调用。 1var object = &#123; proxy: new Proxy(target, handler) &#125;; Proxy 实例也可以作为其他对象的原型对象。 12345678var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);let obj = Object.create(proxy);obj.time // 35 上面代码中，proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截。 同一个拦截器函数，可以设置拦截多个操作。12345678910111213141516171819202122232425var handler = &#123; get: function(target, name) &#123; if (name === 'prototype') &#123; return Object.prototype; &#125; return 'Hello, ' + name; &#125;, apply: function(target, thisBinding, args) &#123; return args[0]; &#125;, construct: function(target, args) &#123; return &#123;value: args[1]&#125;; &#125;&#125;;var fproxy = new Proxy(function(x, y) &#123; return x + y;&#125;, handler);fproxy(1, 2) // 1new fproxy(1,2) // &#123;value: 2&#125;fproxy.prototype === Object.prototype // truefproxy.foo // \"Hello, foo\" 1.2 ReflectReflect对象与Proxy对象一样，也是ES6为了操作对象而提供的新API。Reflect对象的设计目的有这样几个。 （1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。 （2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 // 老写法 12345678910111213try &#123; Object.defineProperty(target, property, attributes); // success&#125; catch (e) &#123; // failure&#125;// 新写法if (Reflect.defineProperty(target, property, attributes)) &#123; // success&#125; else &#123; // failure&#125; （3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。 // 老写法 1'assign' in Object // true // 新写法 1Reflect.has(Object, 'assign') // true （4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 123456789Proxy(target, &#123; set: function(target, name, value, receiver) &#123; var success = Reflect.set(target,name, value, receiver); if (success) &#123; log('property ' + name + ' on ' + target + ' set to ' + value); &#125; return success; &#125;&#125;); 上面代码中，Proxy方法拦截target对象的属性赋值行为。它采用Reflect.set方法将值赋值给对象的属性，然后再部署额外的功能。 下面是另一个例子。 1234567891011121314var loggedObj = new Proxy(obj, &#123; get(target, name) &#123; console.log('get', target, name); return Reflect.get(target, name); &#125;, deleteProperty(target, name) &#123; console.log('delete' + name); return Reflect.deleteProperty(target, name); &#125;, has(target, name) &#123; console.log('has' + name); return Reflect.has(target, name); &#125;&#125;); 上面代码中，每一个Proxy对象的拦截操作（get、delete、has），内部都调用对应的Reflect方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。 有了Reflect对象以后，很多操作会更易读。 // 老写法 1Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1 // 新写法 1Reflect.apply(Math.floor, undefined, [1.75]) // 1","categories":[],"tags":[]},{"title":"柯里化与偏函数","slug":"柯里化与偏函数","date":"2018-03-14T16:00:00.000Z","updated":"2018-05-05T07:22:39.162Z","comments":true,"path":"2018/03/15/柯里化与偏函数/","link":"","permalink":"http://yoursite.com/2018/03/15/柯里化与偏函数/","excerpt":"","text":"柯里化维基百科中对柯里化 (Currying) 的定义为： In mathematics and computer science, currying is the technique of translating the evaluation of a function that takes multiple arguments (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument. 翻译成中文： 在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。 举个例子： 12345678910function add(a, b) &#123; return a + b;&#125;// 执行 add 函数，一次传入两个参数即可add(1, 2) // 3// 假设有一个 curry 函数可以做到柯里化var addCurry = curry(add);addCurry(1)(2) // 3 简单实现123456789101112131415161718192021222324252627282930313233343536function curry(fn, args) &#123; var length = fn.length; args = args || []; return function() &#123; var _args = args.slice(0), arg, i; for (i = 0; i &lt; arguments.length; i++) &#123; arg = arguments[i]; _args.push(arg); &#125; if (_args.length &lt; length) &#123; return curry.call(this, fn, _args); &#125; else &#123; return fn.apply(this, _args); &#125; &#125;&#125;var fn = curry(function(a, b, c) &#123; console.log([a, b, c]);&#125;);fn(\"a\", \"b\", \"c\") // [\"a\", \"b\", \"c\"]fn(\"a\", \"b\")(\"c\") // [\"a\", \"b\", \"c\"]fn(\"a\")(\"b\")(\"c\") // [\"a\", \"b\", \"c\"]fn(\"a\")(\"b\", \"c\") // [\"a\", \"b\", \"c\"] 偏函数维基百科中对偏函数 (Partial application) 的定义为： In computer science, partial application (or partial function application) refers to the process of fixing a number of arguments to a function, producing another function of smaller arity. 翻译成中文： 在计算机科学中，局部应用是指固定一个函数的一些参数，然后产生另一个更小元的函数。 什么是元？元是指函数参数的个数，比如一个带有两个参数的函数被称为二元函数。 举个简单的例子： 1234567891011function add(a, b) &#123; return a + b;&#125;// 执行 add 函数，一次传入两个参数即可add(1, 2) // 3// 假设有一个 partial 函数可以做到局部应用var addOne = partial(add, 1);addOne(2) // 3 柯里化与偏函数柯里化是将一个多参数函数转换成多个单参数函数，也就是将一个 n 元函数转换成 n 个一元函数。 偏函数则是固定一个函数的一个或者多个参数，也就是将一个 n 元函数转换成一个 n - x 元函数。 如果说两者有什么关系的话，引用 functional-programming-jargon 中的描述就是： Curried functions are automatically partially applied. 实现1234567function partial(fn) &#123; var args = [].slice.call(arguments, 1); return function() &#123; var newArgs = args.concat([].slice.call(arguments)); return fn.apply(this, newArgs); &#125;;&#125;;","categories":[],"tags":[]},{"title":"数据结构——二叉树（unfinished）","slug":"二叉树（unfinished）","date":"2017-10-24T16:00:00.000Z","updated":"2018-05-05T08:29:15.273Z","comments":true,"path":"2017/10/25/二叉树（unfinished）/","link":"","permalink":"http://yoursite.com/2017/10/25/二叉树（unfinished）/","excerpt":"","text":"树是一种比较重要的数据结构，尤其是二叉树。二叉树是一种特殊的树，在二叉树中每个节点最多有两个子节点，一般称为左子节点和右子节点（或左孩子和右孩子），并且二叉树的子树有左右之分，其次序不能任意颠倒。二叉树是递归定义的，因此，与二叉树有关的题目基本都可以用递归思想解决，当然有些题目非递归解法也应该掌握，如非递归遍历节点等等。本文努力对二叉树相关题目做一个较全的整理总结。二叉树节点定义如下： 123456# Definition for a binary tree node.class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None 题目列表： 求二叉树中的节点个数 求二叉树的深度 前序遍历，中序遍历，后序遍历4.分层遍历二叉树（按层次从上往下，从左往右） 将二叉查找树变为有序的双向链表 求二叉树第K层的节点个数 求二叉树中叶子节点的个数 判断两棵二叉树是否结构相同 判断二叉树是不是平衡二叉树 求二叉树的镜像 求二叉树中两个节点的最低公共祖先节点 求二叉树中节点的最大距离 由前序遍历序列和中序遍历序列重建二叉树14.判断二叉树是不是完全二叉树 详细解答1. 求二叉树中的节点个数递归解法： 如果二叉树为空，节点个数为0 如果二叉树不为空，二叉树节点个数=左子树节点个数+右子树节点个数+1 参考代码如下：1234567891011class Solution(object): def GetNodeNum(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" if not root: return 0 left=self.GetNodeNum(root.left) right=self.GetNodeNum(root.right) return left+right+1 2. 求二叉树的深度递归解法： 如果二叉树为空,二叉树的深度为0 如果二叉树不为空,二叉树的深度=max(左子树深度，右子树深度)+1 参考代码如下：1234567891011class Solution(object): def maxDepth(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" if not root: return 0 left=self.maxDepth(root.left) right=self.maxDepth(root.right) return left+1 if left &gt; right else right+1 3. 前序遍历，中序遍历，后序遍历前序遍历递归解法： 如果二叉树为空，空操作 如果二叉树不为空，访问根节点，前序遍历左子树，前序遍历右子树 参考代码如下： 递归写法 1234567891011class Solution(object): def PreOrderTraverse(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" if not root: return print root.val // 访问根节点 self.PreOrderTraverse(root.left) //前序遍历左子树 self.PreOrderTraverse(root.right) // 前序遍历右子树 非递归写法preOrder每次都将遇到的节点压入栈，当左子树遍历完毕后才从栈中弹出最后一个访问的节点，访问其右子树。在同一层中，不可能同时有两个节点压入栈，因此栈的大小空间为O(h)，h为二叉树高度。时间方面，每个节点都被压入栈一次，弹出栈一次，访问一次，复杂度为O(n)。 1234567891011121314151617181920class Solution(object): def PreOrderTraverse(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" if not root: return myStack = [] node = root while node or myStack: while node: # 从根节点开始，一直找它的左子树 print node.val myStack.append(node) node = node.left # while结束表示当前节点node为空，即前一个节点没有左子树了 node = myStack.pop() # 开始查看它的右子树 node = node.right 中序遍历递归解法 如果二叉树为空，空操作。 如果二叉树不为空，中序遍历左子树，访问根节点，中序遍历右子树 参考代码如下： 递归写法 1234567891011class Solution(object): def InOrderTraverse(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" if not root: return self.InOrderTraverse(root.left) //前序遍历左子树 print root.val // 访问根节点 self.InOrderTraverse(root.right) // 前序遍历右子树 非递归写法根据上面的先序遍历，可以类似的构造出中序遍历。仔细想一下，只有第一种方法改过来时最方便的。需要的改动仅仅调换一下节点访问的次序，先序是先访问，再入栈；而中序则是先入栈，弹栈后再访问。代码如下。时间复杂度与空间复杂度同先序一致。 1234567891011121314151617181920class Solution(object): def PreOrderTraverse(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" if not root: return myStack = [] node = root while node or myStack: while node: # 从根节点开始，一直找它的左子树 myStack.append(node) node = node.left # while结束表示当前节点node为空，即前一个节点没有左子树了 node = myStack.pop() print node.val # 开始查看它的右子树 node = node.right 后序遍历递归解法 如果二叉树为空，空操作 如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根节点 参考代码如下： 递归写法 1234567891011class Solution(object): def PostOrderTraverse(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" if not root: return self.PostOrderTraverse(root.left) //前序遍历左子树 self.PostOrderTraverse(root.right) // 前序遍历右子树 print root.val // 访问根节点 非递归写法从直觉上来说，后序遍历对比中序遍历难度要增大很多。因为中序遍历节点序列有一点的连续性，而后续遍历则感觉有一定的跳跃性。先左，再右，最后才中间节点；访问左子树后，需要跳转到右子树，右子树访问完毕了再回溯至根节点并访问之，代码如下： 12345678910111213141516171819202122class Solution(object): def PreOrderTraverse(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" res = [] if not root: return res myStack = [] node = root myStack1.append(node) while myStack: # 这个while循环的功能是找出后序遍历的逆序，存在res里面 node = myStack.pop() if node.left: myStack.append(node.left) if node.right: myStack.append(node.right) res.append(node.val) # 将res中的元素出栈，即为后序遍历次序 return res[::-1] 4.分层遍历二叉树（按层次从上往下，从左往右）相当于广度优先搜索，使用队列实现。队列初始化，将根节点压入队列。当队列不为空，进行如下操作：弹出一个节点，访问，若左子节点或右子节点不为空，将其压入队列。123456789101112131415161718class Solution(object): def PreOrderTraverse(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" if not root: return myQueue=[] node=root myQueue.append(node) while myQueue: node=myQueue.pop(0) print node.val if node.left: myQueue.append(node.left) if node.right: myQueue.append(node.right) 5. 将二叉查找树变为有序的双向链表要求不能创建新节点，只调整指针。 递归解法： 如果二叉树查找树为空，不需要转换，对应双向链表的第一个节点是NULL，最后一个节点是NULL 如果二叉查找树不为空：如果左子树为空，对应双向有序链表的第一个节点是根节点，左边不需要其他操作；如果左子树不为空，转换左子树，二叉查找树对应双向有序链表的第一个节点就是左子树转换后双向有序链表的第一个节点，同时将根节点和左子树转换后的双向有序链 表的最后一个节点连接；如果右子树为空，对应双向有序链表的最后一个节点是根节点，右边不需要其他操作；如果右子树不为空，对应双向有序链表的最后一个节点就是右子树转换后双向有序链表的最后一个节点，同时将根节点和右子树转换后的双向有序链表的第一个节点连接。 参考代码如下：12 6. 求二叉树第K层的节点个数递归解法： 如果二叉树为空或者k&lt;1返回0 如果二叉树不为空并且k==1，返回1 如果二叉树不为空且k&gt;1，返回左子树中k-1层的节点个数与右子树k-1层节点个数之和 参考代码如下：1234567891011121314class Solution(Object): def GetNodeNumKthLevel(self,root,k): \"\"\" :type root: TreeNode :type k: int :rtype: int \"\"\" if not root or k &lt; 1: return 0 if root and k == 1: return 1 leftSubTree=self.GetNodeNumKthLevel(root.left,k-1) rightSubTree=self.GetNodeNumKthLevel(root.right,k-1) return leftSubTree+rightSubTree 7. 求二叉树中叶子节点的个数递归解法： 如果二叉树为空，返回0 如果二叉树不为空且左右子树为空，返回1 如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子节点个数 参考代码如下：1234567891011121314class Solution(Object): def GetLeafNodeNum(self,root): \"\"\" :type root: TreeNode :rtype: int \"\"\" if not root: return 0 if root and not root.left and not root.right: return 1 # 分别计算左右子树的叶子结点 leftLeaf=self.GetLeafNodeNum(root.left) rightLeaf=self.GetLeafNodeNum(root.right) return leftLeaf+rightLeaf 8. 判断两棵二叉树是否结构相同不考虑数据内容。结构相同意味着对应的左子树和对应的右子树都结构相同。 递归解法： 如果两棵二叉树都为空，返回真 如果两棵二叉树一棵为空，另一棵不为空，返回假 如果两棵二叉树都不为空，如果对应的左子树和右子树都同构返回真，其他返回假 参考代码如下：12345678910111213class Solution(Object): def StructureCmp(self,root1,root2): \"\"\" :type root1,root2: TreeNode :rtype: Boolean \"\"\" if not root1 and not root2: return True if not root1 or not root2: return False leftRes=self.StructureCmp(root1.left,root2.left) rightRes=self.StructureCmp(root1.right,root2.right) return leftRes and rightRes 9. 判断二叉树是不是平衡二叉树递归解法： 如果二叉树为空，返回真 如果二叉树不为空，如果左子树和右子树都是AVL树并且左子树和右子树高度相差不大于1，返回真，其他返回假 参考代码：1234567891011class Solution(Object): def IsAVL(self,root): \"\"\" :type root: TreeNode :rtype: Boolean \"\"\" if not root: return True leftSubTree=self.IsAVL(root.left) rightSubTree=self.IsAVL(root.right) return leftSubTree and rightSubTree [cpp] view plain copy bool IsAVL(BinaryTreeNode * pRoot, int &amp; height) { if(pRoot == NULL) // 空树，返回真 { height = 0; return true; } int heightLeft; bool resultLeft = IsAVL(pRoot-&gt;m_pLeft, heightLeft); int heightRight; bool resultRight = IsAVL(pRoot-&gt;m_pRight, heightRight); if(resultLeft &amp;&amp; resultRight &amp;&amp; abs(heightLeft - heightRight) &lt;= 1) // 左子树和右子树都是AVL，并且高度相差不大于1，返回真 { height = max(heightLeft, heightRight) + 1; return true; } else { height = max(heightLeft, heightRight) + 1; return false; } } 求二叉树的镜像递归解法：（1）如果二叉树为空，返回空（2）如果二叉树不为空，求左子树和右子树的镜像，然后交换左子树和右子树参考代码如下：[cpp] view plain copy BinaryTreeNode Mirror(BinaryTreeNode pRoot) { if(pRoot == NULL) // 返回NULL return NULL; BinaryTreeNode * pLeft = Mirror(pRoot-&gt;m_pLeft); // 求左子树镜像 BinaryTreeNode * pRight = Mirror(pRoot-&gt;m_pRight); // 求右子树镜像 // 交换左子树和右子树 pRoot-&gt;m_pLeft = pRight; pRoot-&gt;m_pRight = pLeft; return pRoot; } 求二叉树中两个节点的最低公共祖先节点递归解法：（1）如果两个节点分别在根节点的左子树和右子树，则返回根节点（2）如果两个节点都在左子树，则递归处理左子树；如果两个节点都在右子树，则递归处理右子树参考代码如下：[cpp] view plain copy bool FindNode(BinaryTreeNode pRoot, BinaryTreeNode pNode) { if(pRoot == NULL || pNode == NULL) return false; if(pRoot == pNode) return true; bool found = FindNode(pRoot-&gt;m_pLeft, pNode); if(!found) found = FindNode(pRoot-&gt;m_pRight, pNode); return found; } BinaryTreeNode GetLastCommonParent(BinaryTreeNode pRoot, BinaryTreeNode * pNode1, BinaryTreeNode * pNode2) { if(FindNode(pRoot-&gt;m_pLeft, pNode1)) { if(FindNode(pRoot-&gt;m_pRight, pNode2)) return pRoot; else return GetLastCommonParent(pRoot-&gt;m_pLeft, pNode1, pNode2); } else { if(FindNode(pRoot-&gt;m_pLeft, pNode2)) return pRoot; else return GetLastCommonParent(pRoot-&gt;m_pRight, pNode1, pNode2); } }递归解法效率很低，有很多重复的遍历，下面看一下非递归解法。非递归解法：先求从根节点到两个节点的路径，然后再比较对应路径的节点就行，最后一个相同的节点也就是他们在二叉树中的最低公共祖先节点参考代码如下：[cpp] view plain copy bool GetNodePath(BinaryTreeNode pRoot, BinaryTreeNode pNode, list &amp; path) { if(pRoot == pNode) { path.push_back(pRoot); return true; } if(pRoot == NULL) return false; path.push_back(pRoot); bool found = false; found = GetNodePath(pRoot-&gt;m_pLeft, pNode, path); if(!found) found = GetNodePath(pRoot-&gt;m_pRight, pNode, path); if(!found) path.pop_back(); return found; } BinaryTreeNode GetLastCommonParent(BinaryTreeNode pRoot, BinaryTreeNode pNode1, BinaryTreeNode pNode2) { if(pRoot == NULL || pNode1 == NULL || pNode2 == NULL) return NULL; list&lt;BinaryTreeNode*&gt; path1; bool bResult1 = GetNodePath(pRoot, pNode1, path1); list&lt;BinaryTreeNode*&gt; path2; bool bResult2 = GetNodePath(pRoot, pNode2, path2); if(!bResult1 || !bResult2) return NULL; BinaryTreeNode * pLast = NULL; list&lt;BinaryTreeNode*&gt;::const_iterator iter1 = path1.begin(); list&lt;BinaryTreeNode*&gt;::const_iterator iter2 = path2.begin(); while(iter1 != path1.end() &amp;&amp; iter2 != path2.end()) { if(iter1 == iter2) pLast = *iter1; else break; iter1++; iter2++; } return pLast; } 在上述算法的基础上稍加变化即可求二叉树中任意两个节点的距离了。 求二叉树中节点的最大距离即二叉树中相距最远的两个节点之间的距离。递归解法：（1）如果二叉树为空，返回0，同时记录左子树和右子树的深度，都为0（2）如果二叉树不为空，最大距离要么是左子树中的最大距离，要么是右子树中的最大距离，要么是左子树节点中到根节点的最大距离+右子树节点中到根节点的最大距离，同时记录左子树和右子树节点中到根节点的最大距离。参考代码如下：[cpp] view plain copy int GetMaxDistance(BinaryTreeNode * pRoot, int &amp; maxLeft, int &amp; maxRight) { // maxLeft, 左子树中的节点距离根节点的最远距离 // maxRight, 右子树中的节点距离根节点的最远距离 if(pRoot == NULL) { maxLeft = 0; maxRight = 0; return 0; } int maxLL, maxLR, maxRL, maxRR; int maxDistLeft, maxDistRight; if(pRoot-&gt;m_pLeft != NULL) { maxDistLeft = GetMaxDistance(pRoot-&gt;m_pLeft, maxLL, maxLR); maxLeft = max(maxLL, maxLR) + 1; } else { maxDistLeft = 0; maxLeft = 0; } if(pRoot-&gt;m_pRight != NULL) { maxDistRight = GetMaxDistance(pRoot-&gt;m_pRight, maxRL, maxRR); maxRight = max(maxRL, maxRR) + 1; } else { maxDistRight = 0; maxRight = 0; } return max(max(maxDistLeft, maxDistRight), maxLeft+maxRight); } 由前序遍历序列和中序遍历序列重建二叉树二叉树前序遍历序列中，第一个元素总是树的根节点的值。中序遍历序列中，左子树的节点的值位于根节点的值的左边，右子树的节点的值位于根节点的值的右边。递归解法：（1）如果前序遍历为空或中序遍历为空或节点个数小于等于0，返回NULL。（2）创建根节点。前序遍历的第一个数据就是根节点的数据，在中序遍历中找到根节点的位置，可分别得知左子树和右子树的前序和中序遍历序列，重建左右子树。[cpp] view plain copy BinaryTreeNode RebuildBinaryTree(int pPreOrder, int* pInOrder, int nodeNum) { if(pPreOrder == NULL || pInOrder == NULL || nodeNum &lt;= 0) return NULL; BinaryTreeNode * pRoot = new BinaryTreeNode; // 前序遍历的第一个数据就是根节点数据 pRoot-&gt;m_nValue = pPreOrder[0]; pRoot-&gt;m_pLeft = NULL; pRoot-&gt;m_pRight = NULL; // 查找根节点在中序遍历中的位置，中序遍历中，根节点左边为左子树，右边为右子树 int rootPositionInOrder = -1; for(int i = 0; i &lt; nodeNum; i++) if(pInOrder[i] == pRoot-&gt;m_nValue) { rootPositionInOrder = i; break; } if(rootPositionInOrder == -1) { throw std::exception(“Invalid input.”); } // 重建左子树 int nodeNumLeft = rootPositionInOrder; int * pPreOrderLeft = pPreOrder + 1; int * pInOrderLeft = pInOrder; pRoot-&gt;m_pLeft = RebuildBinaryTree(pPreOrderLeft, pInOrderLeft, nodeNumLeft); // 重建右子树 int nodeNumRight = nodeNum - nodeNumLeft - 1; int * pPreOrderRight = pPreOrder + 1 + nodeNumLeft; int * pInOrderRight = pInOrder + nodeNumLeft + 1; pRoot-&gt;m_pRight = RebuildBinaryTree(pPreOrderRight, pInOrderRight, nodeNumRight); return pRoot; }同样，有中序遍历序列和后序遍历序列，类似的方法可重建二叉树，但前序遍历序列和后序遍历序列不同恢复一棵二叉树，证明略。14.判断二叉树是不是完全二叉树若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。有如下算法，按层次（从上到下，从左到右）遍历二叉树，当遇到一个节点的左子树为空时，则该节点右子树必须为空，且后面遍历的节点左右子树都必须为空，否则不是完全二叉树。[cpp] view plain copy bool IsCompleteBinaryTree(BinaryTreeNode * pRoot) { if(pRoot == NULL) return false; queue q; q.push(pRoot); bool mustHaveNoChild = false; bool result = true; while(!q.empty()) { BinaryTreeNode * pNode = q.front(); q.pop(); if(mustHaveNoChild) // 已经出现了有空子树的节点了，后面出现的必须为叶节点（左右子树都为空） { if(pNode-&gt;m_pLeft != NULL || pNode-&gt;m_pRight != NULL) { result = false; break; } } else { if(pNode-&gt;m_pLeft != NULL &amp;&amp; pNode-&gt;m_pRight != NULL) { q.push(pNode-&gt;m_pLeft); q.push(pNode-&gt;m_pRight); } else if(pNode-&gt;m_pLeft != NULL &amp;&amp; pNode-&gt;m_pRight == NULL) { mustHaveNoChild = true; q.push(pNode-&gt;m_pLeft); } else if(pNode-&gt;m_pLeft == NULL &amp;&amp; pNode-&gt;m_pRight != NULL) { result = false; break; } else { mustHaveNoChild = true; } } } return result; }","categories":[],"tags":[]},{"title":"JavaScript 数组遍历方法简单实现","slug":"JS 数组遍历方法简单实现","date":"2017-10-21T16:00:00.000Z","updated":"2018-05-05T08:29:47.370Z","comments":true,"path":"2017/10/22/JS 数组遍历方法简单实现/","link":"","permalink":"http://yoursite.com/2017/10/22/JS 数组遍历方法简单实现/","excerpt":"","text":"Array.prototype.forEach()12345678910111213if(!Array.prototype.forEach)&#123; Array.prototype.forEach = function(callback,context)&#123; var target = Object(this); var len = target.length; var k = 0; while(k &lt; len)&#123; if(k in target)&#123; callback.call(context,target[k],k,target); &#125; k++; &#125; &#125;&#125; Array.prototype.map()1234567891011121314if(!Array.prototype.map)&#123; Array.prototype.map = function(callback,context)&#123; var target = Object(this); var len = target.length; var k = 0, arr = []; while(k &lt; len)&#123; if(k in target)&#123; arr.push(callback.call(context,target[k],k,target)); &#125; k++; &#125; return arr; &#125;&#125; Array.prototype.filter()1234567891011121314if(!Array.prototype.filter)&#123; Array.prototype.filter = function(calback,context)&#123; var target = Object(this); var len = target.length; var k = 0, arr = []; while(k &lt; len)&#123; if(k in target)&#123; callback.call(context,target[k],k,target) &amp;&amp; arr.push(target[k]) &#125; k++; &#125; return arr; &#125;&#125; Array.prototype.reduce()123456789101112131415if(!Array.prototype.reduce)&#123; Array.prototype.reduce = function(callback,initialValue)&#123; var target = Object(this); var len = target.length; var initial = initialValue || target[0]; var k = !!initialValue?0:1; while(k &lt; len)&#123; if(k in target)&#123; initial = callback(initial,target[k],k,target); &#125; k++; &#125; return initial; &#125;&#125;","categories":[],"tags":[]},{"title":"Redux 源码分析","slug":"redux 源码分析","date":"2017-10-08T16:00:00.000Z","updated":"2018-05-05T08:21:48.575Z","comments":true,"path":"2017/10/09/redux 源码分析/","link":"","permalink":"http://yoursite.com/2017/10/09/redux 源码分析/","excerpt":"","text":"ReduxcombineReducers1234567891011121314// 回顾一下combineReducers的使用格式// 两个reducerconst todos = (state = INIT.todos, action) =&gt; &#123; // ....&#125;;const filterStatus = (state = INIT.filterStatus, action) =&gt; &#123; // ...&#125;;const appReducer = combineReducers(&#123; todos, filterStatus&#125;); 还记得combineReducers的黑魔法吗？即： 传入的Object参数中，对象的key与value所代表的reducer function同名 各个reducer function的名称和需要传入该reducer的state参数同名。 源码标注解读（省略部分）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192export default function combineReducers(reducers) &#123; // 第一次筛选，参数reducers为Object // 筛选掉reducers中不是function的键值对 var reducerKeys = Object.keys(reducers); var finalReducers = &#123;&#125; for (var i = 0; i &lt; reducerKeys.length; i++) &#123; var key = reducerKeys[i]; if (typeof reducers[key] === 'function') &#123; finalReducers[key] = reducers[key] &#125; &#125; var finalReducerKeys = Object.keys(finalReducers) // 二次筛选，判断reducer中传入的值是否合法（!== undefined） // 获取筛选完之后的所有key var sanityError try &#123; // assertReducerSanity函数用于遍历finalReducers中的reducer，检查传入reducer的state是否合法 assertReducerSanity(finalReducers) &#125; catch (e) &#123; sanityError = e &#125; // 返回一个function。该方法接收state和action作为参数 return function combination(state = &#123;&#125;, action) &#123; // 如果之前的判断reducers中有不法值，则抛出错误 if (sanityError) &#123; throw sanityError &#125; // 如果不是production环境则抛出warning if (process.env.NODE_ENV !== 'production') &#123; var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action) if (warningMessage) &#123; warning(warningMessage) &#125; &#125; var hasChanged = false var nextState = &#123;&#125; // 遍历所有的key和reducer，分别将reducer对应的key所代表的state，代入到reducer中进行函数调用 for (var i = 0; i &lt; finalReducerKeys.length; i++) &#123; var key = finalReducerKeys[i] var reducer = finalReducers[key] // 这也就是为什么说combineReducers黑魔法--要求传入的Object参数中，reducer function的名称和要和state同名的原因 var previousStateForKey = state[key] var nextStateForKey = reducer(previousStateForKey, action) // 如果reducer返回undefined则抛出错误 if (typeof nextStateForKey === 'undefined') &#123; var errorMessage = getUndefinedStateErrorMessage(key, action) throw new Error(errorMessage) &#125; // 将reducer返回的值填入nextState nextState[key] = nextStateForKey // 如果任一state有更新则hasChanged为true hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; return hasChanged ? nextState : state &#125;&#125;// 检查传入reducer的state是否合法function assertReducerSanity(reducers) &#123; Object.keys(reducers).forEach(key =&gt; &#123; var reducer = reducers[key] // 遍历全部reducer，并给它传入(undefined, action) // 当第一个参数传入undefined时，则为各个reducer定义的默认参数 var initialState = reducer(undefined, &#123; type: ActionTypes.INIT &#125;) // ActionTypes.INIT几乎不会被定义，所以会通过switch的default返回reducer的默认参数。如果没有指定默认参数，则返回undefined，抛出错误 if (typeof initialState === 'undefined') &#123; throw new Error( `Reducer \"$&#123;key&#125;\" returned undefined during initialization. ` + `If the state passed to the reducer is undefined, you must ` + `explicitly return the initial state. The initial state may ` + `not be undefined.` ) &#125; var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.') if (typeof reducer(undefined, &#123; type &#125;) === 'undefined') &#123; throw new Error( `Reducer \"$&#123;key&#125;\" returned undefined when probed with a random type. ` + `Don't try to handle $&#123;ActionTypes.INIT&#125; or other actions in \"redux/*\" ` + `namespace. They are considered private. Instead, you must return the ` + `current state for any unknown actions, unless it is undefined, ` + `in which case you must return the initial state, regardless of the ` + `action type. The initial state may not be undefined.` ) &#125; &#125;)&#125; createStore12// 回顾下使用方法const store = createStore(reducers, state, enhance); 源码标注解读（省略部分）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// 对于未知的action.type，reducer必须返回默认的参数state。这个ActionTypes.INIT就可以用来监测当reducer传入未知type的action时，返回的state是否合法export var ActionTypes = &#123; INIT: '@@redux/INIT'&#125;export default function createStore(reducer, initialState, enhancer) &#123; // 检查你的state和enhance参数有没有传反 if (typeof initialState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = initialState initialState = undefined &#125; // 如果有传入合法的enhance，则通过enhancer再调用一次createStore if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)(reducer, initialState) &#125; if (typeof reducer !== 'function') &#123; throw new Error('Expected the reducer to be a function.') &#125; var currentReducer = reducer var currentState = initialState var currentListeners = [] var nextListeners = currentListeners var isDispatching = false // 是否正在分发事件 function ensureCanMutateNextListeners() &#123; if (nextListeners === currentListeners) &#123; nextListeners = currentListeners.slice() &#125; &#125; // 我们在action middleware中经常使用的getState()方法，返回当前state function getState() &#123; return currentState &#125; // 注册listener，同时返回一个取消事件注册的方法。当调用store.dispatch的时候调用listener function subscribe(listener) &#123; if (typeof listener !== 'function') &#123; throw new Error('Expected listener to be a function.') &#125; var isSubscribed = true ensureCanMutateNextListeners() nextListeners.push(listener) return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; isSubscribed = false // 从nextListeners中去除掉当前listener ensureCanMutateNextListeners() var index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125; &#125; // dispatch方法接收的action是个对象，而不是方法。 // 这个对象实际上就是我们自定义action的返回值，因为dispatch的时候，已经调用过我们的自定义action了，比如 dispatch(addTodo()) function dispatch(action) &#123; if (!isPlainObject(action)) &#123; throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ) &#125; if (typeof action.type === 'undefined') &#123; throw new Error( 'Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?' ) &#125; // 调用dispatch的时候只能一个个调用，通过dispatch判断调用的状态 if (isDispatching) &#123; throw new Error('Reducers may not dispatch actions.') &#125; try &#123; isDispatching = true currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; // 遍历调用各个linster var listeners = currentListeners = nextListeners for (var i = 0; i &lt; listeners.length; i++) &#123; listeners[i]() &#125; return action &#125; // Replaces the reducer currently used by the store to calculate the state. function replaceReducer(nextReducer) &#123; if (typeof nextReducer !== 'function') &#123; throw new Error('Expected the nextReducer to be a function.') &#125; currentReducer = nextReducer dispatch(&#123; type: ActionTypes.INIT &#125;) &#125; // 当create store的时候，reducer会接受一个type为ActionTypes.INIT的action，使reducer返回他们默认的state，这样可以快速的形成默认的state的结构 dispatch(&#123; type: ActionTypes.INIT &#125;) return &#123; dispatch, subscribe, getState, replaceReducer &#125;&#125; thunkMiddleware源码及其简单简直给跪… 12345678910// 返回以 dispatch 和 getState 作为参数的actionexport default function thunkMiddleware(&#123; dispatch, getState &#125;) &#123; return next =&gt; action =&gt; &#123; if (typeof action === 'function') &#123; return action(dispatch, getState); &#125; return next(action); &#125;;&#125; applyMiddleware先复习下用法： 123456789// usageimport &#123; createStore, applyMiddleware &#125; from 'redux';import thunkMiddleware from 'redux-thunk';const store = createStore( reducers, state, applyMiddleware(thunkMiddleware)); applyMiddleware首先接收thunkMiddleware作为参数，两者组合成为一个新的函数（enhance），之后在createStore内部，因为enhance的存在，将会变成返回enhancer(createStore)(reducer, initialState) 源码标注解读（省略部分）： 123456789101112131415161718192021222324252627282930313233343536373839// 定义一个代码组合的方法// 传入一些function作为参数，返回其链式调用的形态。例如，// compose(f, g, h) 最终返回 (...args) =&gt; f(g(h(...args)))export default function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; else &#123; const last = funcs[funcs.length - 1] const rest = funcs.slice(0, -1) return (...args) =&gt; rest.reduceRight((composed, f) =&gt; f(composed), last(...args)) &#125;&#125;export default function applyMiddleware(...middlewares) &#123; // 最终返回一个以createStore为参数的匿名函数 // 这个函数返回另一个以reducer, initialState, enhancer为参数的匿名函数 return (createStore) =&gt; (reducer, initialState, enhancer) =&gt; &#123; var store = createStore(reducer, initialState, enhancer) var dispatch var chain = [] var middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action) &#125; // 每个 middleware 都以 middlewareAPI 作为参数进行注入，返回一个新的链。此时的返回值相当于调用 thunkMiddleware 返回的函数： (next) =&gt; (action) =&gt; &#123;&#125; ，接收一个next作为其参数 chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) // 并将链代入进 compose 组成一个函数的调用链 // compose(...chain) 返回形如(...args) =&gt; f(g(h(...args)))，f/g/h都是chain中的函数对象。 // 在目前只有 thunkMiddleware 作为 middlewares 参数的情况下，将返回 (next) =&gt; (action) =&gt; &#123;&#125; // 之后以 store.dispatch 作为参数进行注入 dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125; 一脸懵逼？没关系，来结合实际使用总结一下： 当我们搭配redux-thunk这个库的时候，在redux配合components时，通常这么写 123456import thunkMiddleware from 'redux-thunk';import &#123; createStore, applyMiddleware, combineReducer &#125; from 'redux';import * as reducers from './reducers.js';const appReducer = combineReducer(reducers);const store = createStore(appReducer, initialState, applyMiddleware(thunkMiddleware)); 还记得当createStore收到的参数中有enhance时会怎么做吗？ 1234567// createStore.jsif (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)(reducer, initialState)&#125; 也就是说，会变成下面的情况 1applyMiddleware(thunkMiddleware)(createStore)(reducer, initialState) applyMiddleware(thunkMiddleware) applyMiddleware接收thunkMiddleware作为参数，返回形如(createStore) =&gt; (reducer, initialState, enhancer) =&gt; {}的函数。 applyMiddleware(thunkMiddleware)(createStore) 以 createStore 作为参数，调用上一步返回的函数(reducer, initialState, enhancer) =&gt; {} applyMiddleware(thunkMiddleware)(createStore)(reducer, initialState) 以（reducer, initialState）为参数进行调用。在这个函数内部，thunkMiddleware被调用，其作用是监测type是function的action 因此，如果dispatch的action返回的是一个function，则证明是中间件，则将(dispatch, getState)作为参数代入其中，进行action 内部下一步的操作。否则的话，认为只是一个普通的action，将通过next(也就是dispatch)进一步分发 也就是说，applyMiddleware(thunkMiddleware)作为enhance，最终起了这样的作用： 对dispatch调用的action(例如，dispatch(addNewTodo(todo)))进行检查，如果action在第一次调用之后返回的是function，则将(dispatch, getState)作为参数注入到action返回的方法中，否则就正常对action进行分发，这样一来我们的中间件就完成喽~ 因此，当action内部需要获取state，或者需要进行异步操作，在操作完成之后进行事件调用分发的话，我们就可以让action 返回一个以(dispatch, getState)为参数的function而不是通常的Object，enhance就会对其进行检测以便正确的处理 https://www.cnblogs.com/lijiayi/p/reduxcurry.html","categories":[],"tags":[]},{"title":"JavaScript replace 方法详解","slug":"JS正则表达式replace方法详解","date":"2017-09-26T16:00:00.000Z","updated":"2018-05-05T08:26:09.479Z","comments":true,"path":"2017/09/27/JS正则表达式replace方法详解/","link":"","permalink":"http://yoursite.com/2017/09/27/JS正则表达式replace方法详解/","excerpt":"","text":"replace方法是javascript涉及到正则表达式中较为复杂的一个方法，严格上说应该是string对象的方法。只不过牵扯到正则的时候比较多一些。需要我们灵活的使用。 语法：stringObj.replace(regexp/substr,replacement)； 第一个参数：必需。字符串中要替换的子串或正则RexExp； 第二个参数：必需，一个字符串值，规定了替换文本或生成替换文本的函数。 返回值：注意它的返回值是一个新的字符串，并没有更改原有字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。所以根据它的参数的不同分为很多种情况，以下一一对各种情况加以分析： NO.1 两个参数都是字符串123var str1 = '这是一段原始文本，需要替换的内容\"这要替换\"！';var newStr = str1.replace('这要替换','need replace');console.log( newStr ); //输出： 这是一段原始文本，需要替换的内容\"need replace\"！ 上面的例子中第二个参数字符串’need replace’,替换掉了第一个参数字符串’这要替换’。这是最简单的一种形式。 NO.2 第一个参数是正则，第二个参数是字符串123var str2 = '这是一段原始文本，需要替换的内容\"ac这要替换bb\"！';var newStr = str2.replace( /([a-z])+/g,'qqq' );console.log( newStr ); //输出： 这是一段原始文本，需要替换的内容\"qqq这要替换qqq\"！ 上面的例子字符串’qqq’,替换了正则匹配的内容。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。 NO.3 第一个参数是正则，第二个参数是带$符的字符串123var str3 = '这是一段原始文本,\"3c这要替换4d\"!';var newStr = str3.replace( /([0-9])([a-z])/g,\"$1\" );console.log( newStr ); //输出： 这是一段原始文本,\"3这要替换4\"!'; 上面的例子，$1表示regexp中的第一个子表示即（[0-9]）匹配单个数字，同理若是$2则表示第二个子表示即（[a-z]）；所以，’3c’这个匹配到的整体被第一个子表示说表示的’3’替换，’4d’被第一个子表示匹配的数字’4’所替换。其他几个同理可得： （/([0-9])([a-z])/g,”$2″）—&gt;////输出： 这是一段原始文本,”c这要替换d”!’; (3c和4d被相应的第二个子表示匹配出来的c和d替换)（/([0-9])([a-z])/g,”$’”）—&gt;////输出： 这是一段原始文本,”这要替换d”!这要替换”!”!’; (3c被3c右侧文本替换，4d右侧是”!替换，所以出现俩次) NO.4 第一个参数是正则，第二个参数函数123456789var str4 = '这是一段原始文本，需要替换的内容\"aa这要bbb替换ccccc\"！';var newStr = str4.replace( /[a-z]+/g,function ($0)&#123; var str = ''; for (var i = 0; i &lt; $0.length; i++) &#123; str += '*'; &#125;; return str;&#125; );console.log( newStr ); //这是一段原始文本，需要替换的内容\"**这要***替换*****\"！ 上面的例子函数的第一个参数为匹配的regexp的整体，根据长度函数返回值为相应替换的文本； NO.5 第一个参数是正则且有子表达式，第二个参数函数且带有多个参数12345678910111213141516171819var str5 = '这是一段原始文本，需要替换的内容\"3c这要替换4d\"！';var newStr = str5.replace( /([0-9])([a-z])/g,function (arg1,arg2,arg3,arg4,arg5)&#123; console.log( arg1 ); console.log( arg2 ); console.log( arg3 ); console.log( arg4 ); console.log( arg5 );&#125; );//输出：3c3c17这是一段原始文本，需要替换的内容\"3c这要替换4d\"！4d4d23这是一段原始文本，需要替换的内容\"3c这要替换4d\"！ 上面的例子第一个参数arg1表示匹配的整体，arg2表示第一个子表达式，arg3表示第二个子表达式，接下来的参数arg4是一个整数，声明了表示子匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。","categories":[],"tags":[]},{"title":"JavaScript 数组乱序实现","slug":"数组乱序实现","date":"2017-09-21T16:00:00.000Z","updated":"2018-05-05T07:23:40.971Z","comments":true,"path":"2017/09/22/数组乱序实现/","link":"","permalink":"http://yoursite.com/2017/09/22/数组乱序实现/","excerpt":"","text":"方案一一般比较经典且流行的方案为：对对象数组采用array.sort()方法，并传入一个比较函数（comparison function），这个比较函数随机返回一个介于［－0.5， 0.5］之间的数值： 1234var numbers = [12,4,16,3];numbers.sort(function() &#123; return .5 - Math.random();&#125;); 方案二1234567891011Array.prototype.shuffle = function() &#123; var input = this; for (var i = input.length-1; i &gt;=0; i--) &#123; var randomIndex = Math.floor(Math.random()*(i+1)); [input[i],input[randomIndex]] = [input[randomIndex],input[i]] &#125; return input;&#125;var tempArray = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]tempArray.shuffle();console.log(tempArray);","categories":[],"tags":[]},{"title":"JavaScript 之 bind 实现","slug":"JS-bind实现","date":"2017-09-01T16:00:00.000Z","updated":"2018-05-05T07:21:38.155Z","comments":true,"path":"2017/09/02/JS-bind实现/","link":"","permalink":"http://yoursite.com/2017/09/02/JS-bind实现/","excerpt":"","text":"bind函数究竟是什么?在开启我们的探索之前，有必要先明确一下bind到底实现了什么： 简单粗暴地来说，bind是用于绑定this指向的。（如果你还不了解JS中this的指向问题，以及执行环境上下文的奥秘，这篇文章暂时就不太适合阅读）。 bind使用语法： fun.bind(thisArg[, arg1[, arg2[, …]]])bind方法会创建一个新函数。当这个新函数被调用时，bind的第一个参数将作为它运行时的this，之后的一序列参数将会在传递的实参前传入作为它的参数。本文不打算科普基础，如果您还不清楚，请参考MDN内容。 bind返回的绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的this值被忽略，同时调用时的参数被提供给模拟函数。 初级实现了解了以上内容，我们来实现一个初级的bind函数Polyfill: 1234567Function.prototype.bind = function (context) &#123; var me = this; var argsArray = Array.prototype.slice.call(arguments); return function () &#123; return me.apply(context, argsArray.slice(1)) &#125;&#125; 基本原理是使用apply进行模拟。函数体内的this，就是需要绑定this的实例函数，或者说是原函数。最后我们使用apply来进行参数（context）绑定，并返回。同时，将第一个参数（context）以外的其他参数，作为提供给原函数的预设参数，这也是基本的“颗粒化（curring）”基础。 初级实现的加分项上面的实现（包括后面的实现），其实是一个典型的“Monkey patching(猴子补丁)”，即“给内置对象扩展方法”。 123Function.prototype.bind = Function.prototype.bind || function (context) &#123; ...&#125; 颗粒化（curring）实现上述的实现方式中，我们返回的参数列表里包含：atgsArray.slice(1)，他的问题在于存在预置参数功能丢失的现象。想象我们返回的绑定函数中，如果想实现预设传参（就像bind所实现的那样），就面临尴尬的局面。真正实现颗粒化的“完美方式”是： 123456789Function.prototype.bind = Function.prototype.bind || function (context) &#123; var me = this; var args = Array.prototype.slice.call(arguments, 1); return function () &#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return me.apply(context, finalArgs); &#125;&#125; 。但是，我们注意在上边bind方法介绍的第三条提到：bind返回的函数如果作为构造函数，搭配new关键字出现的话，我们的绑定this就需要“被忽略”。 构造函数场景下的兼容有了上边的讲解，不难理解需要兼容构造函数场景的实现： 12345678910111213Function.prototype.bind = Function.prototype.bind || function (context) &#123; var me = this; var args = Array.prototype.slice.call(arguments, 1); var F = function () &#123;&#125;; F.prototype = this.prototype; var bound = function () &#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return me.apply(this instanceof F ? this : context || this, finalArgs); &#125; bound.prototype = new F(); return bound;&#125;","categories":[],"tags":[]},{"title":"字符编码之ASCII，Unicode与UTF","slug":"字符编码之ASCII，Unicode与UTF","date":"2017-08-04T16:00:00.000Z","updated":"2018-05-05T07:27:38.214Z","comments":true,"path":"2017/08/05/字符编码之ASCII，Unicode与UTF/","link":"","permalink":"http://yoursite.com/2017/08/05/字符编码之ASCII，Unicode与UTF/","excerpt":"","text":"一、ASCII 码我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。 上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。 ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。 二、Unicode 码英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。 但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0–127表示的符号是一样的，不一样的只是128–255的这一段。 至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。 中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。 正如上文所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。 可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。 Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。 Unicode 的基本元素是码位（code point），共包含1114112个码位。码位通过使用数值表示，数值格式为：U+hhhh，其中每个h代表一个十六进制数字。 Unicode 的所有码位组成了一个编码空间。在Unicode编码空间，Unicode码位分为17组编排，每组称为平面（Plane），而每平面拥有65536个码位。如下图所示： Unicode 遵守既定规则把世界上的字符一一映射到码位中。被使用的码位，其码点值就是对应字符的Unicode编码。如：U+0041 表示拉丁字母 “A”；U+40000 由于没使用，不表示任何字符。 截止目前，才128237 个码位被使用——编码空间的 12% 被赋值，在后面还有很多空间可应对新出现的字符。 三、Unicode的问题需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。 这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 它们造成的结果是：1）出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。2）Unicode 在很长一段时间内无法推广，直到互联网的出现。 四、UTF-8编码互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。 UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8 的编码规则很简单，只有二条： 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 下表总结了编码规则，字母x表示可用编码的位。 Unicode符号范围（16进制） UTF-8编码方式（2进制） 0000 0000-0000 007F 0xxxxxxx 0000 0080-0000 07FF 110xxxxx 10xxxxxx 0000 0800-0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。 下面，还是以汉字严为例，演示如何实现 UTF-8 编码。 严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。 五、UTF-16编码UTF-16是一种可变长度字符编码方式，以16-bit 为单元，使用2个或4个字节为每个字符编码。 UTF-16的编码规则如下： Unicode编码范围 （16进制） 占用字节 UTF-16 编码（2进制） U+0000 - U+FFFF 2 xxxxxxxx xxxxxxxx U+10000 - U+10FFFF 4 110110yyyyyyyyyy 110111xxxxxxxxxx 把字符的Unicode编码记作 U 若U &lt; 0x10000，字符的UTF-16编码就是U对应的16位二进制：xxxxxxxx xxxxxxxx 若U ≥ 0x10000，则把字符拆分为2部分（U+10000 ~ U+10FFFF的空间大小是2^20），前十位映射到U+D800U+DBFF，后十位映射到U+DC00U+DFFF。具体拆分计算如下： 计算U’=U-0x10000， 将U’写成二进制形式：yyyy yyyy yyxx xxxx xxxx， 按照110110yyyyyyyyyy 110111xxxxxxxxxx格式填入，即得到U的UTF-16编码（二进制）：110110yyyyyyyyyy 110111xxxxxxxxxx 在基本平面（0x00000xFFFF）内，U+D800U+DFFF是一个空段，即这些码位不对应任何字符 辅助平面（0x10000~0x10FFFF）的字符位共有2^20个 U+D800U+DBFF，空间大小是2^10；U+DC00U+DFFF，空间大小是2^10。二者组合起来，正好可以表示辅助平面的字符。即：辅助平面的字符可以拆分为两个基本平面的字符表示——字符前10位映射在U+D800到U+DBFF，后10位映射在U+DC00到U+DFFF 下面，以汉字“鱼”和字符“𝌀”为例，演示如何实现UTF-16编码。 “鱼”的Unicode编码是9C7C，根据上表，9C7C &lt; 0x10000 ，其UTF-16编码就是其Unicode编码：1001 1100 0111 1100，即0x9C7C。 “𝌀”的Unicode编码是1D300，根据上表，1D300 &gt; 0x10000，然后减去0x10000，得到0xD300，按yyyy yyyy yyxx xxxx xxxx格式写成二进制是：0000 1101 0011 0000 0000，然后按照110110yyyyyyyyyy 110111xxxxxxxxxx格式填入，得到“𝌀”的UTF-16编码（二进制）：1101100000110100 1101111100000000，即0xD834 0xDF00。 参考资料 字符编码笔记：ASCII，Unicode 和 UTF-8 Unicode和UTF-8、UTF-16","categories":[],"tags":[]},{"title":"First Blog","slug":"hello-world","date":"2017-05-04T16:00:00.000Z","updated":"2018-05-05T07:28:11.857Z","comments":true,"path":"2017/05/05/hello-world/","link":"","permalink":"http://yoursite.com/2017/05/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}